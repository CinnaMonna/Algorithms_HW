1. Метод сортировки heapSort - первый этап: 

В цикле for вызывается метод построения восходящей кучи heapify, 
которой в качестве параметра  - корня поддерева - передаются поочередно 
индексы массива в обратном порядке начиная с (n//2 - 1) до 0, где n - размер массива 
(у индексов больших, чем (n//2 - 1), нет детей).
Таким образом внутри цикла происходит построение восходящей кучи (родитель больше по значению, чем дети) 
сначала на нижних поддеревьях (более старшие индексы), затем выше, пока не достигнет корня всей кучи - индекса 0. В результате максимальный элемент массива оказывается на позиции 0.

2. Метод сортировки heapSort - второй этап: 

Меняем местами 0-й и последний (n-1)-й элементы массива. Максимальный элемент оказывается в конце, "отсекаем" его от остальной неотсортированной части. Повторяем построение восходящей кучи на оставшемся массиве и обмен элементов - 0-го с последним элементов из рассматриваемой части массива. Для этого в цикле for после обмена элементов вызваем метод heapify, в качестве параметров передаем: корень поддерева - индекс 0, размер кучи - значение i, которое с каждым шагом в цикле будет уменьшаться от (n-1) до 0. По завершении этого этапа массив полностью отсортирован.

3. Метод построения восходящей кучи heapify:

По формулам построения кучи определяем индексы потомков корня поддерева (корень поддерева - элемент с индеком, переданным в качестве параметра в метод). Если один из потомков больше корня, меняем его местами с корнем - меняем позиции этих элементов в массиве. В этот момент переменная largest хранит индекс, который имел бОльший потомок до обмена местами с корнем. Рекурсивно вызываем метод heapify с парамтром largest в качестве индекса корня поддерева - тем самым преобразуем в восходящую кучу затронутое поддерево.  




